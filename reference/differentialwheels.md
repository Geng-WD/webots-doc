## DifferentialWheels

Derived from `Robot`.


```
DifferentialWheels {
  SFFloat   motorConsumption    0      # [0,inf)
  SFFloat   axleLength          0.1    # (0,inf)
  SFFloat   wheelRadius         0.01   # (0,inf)
  SFFloat   maxSpeed            10     # (0,inf)
  SFFloat   maxAcceleration     10     
  SFFloat   speedUnit           1
  SFFloat   slipNoise           0.1    # [0,inf)
  SFFloat   encoderNoise        -1
  SFFloat   encoderResolution   -1
  SFFloat   maxForce            0.3    # (0,inf)
}
```

### Description

The `DifferentialWheels` node can be used as base node to build robots with two
wheels and differential steering. Any other type of robot (legged, humanoid,
vehicle, etc.) needs to use `Robot` as base node.

A `DifferentialWheels` robot will automatically take control of its wheels if
they are placed in the `children` field. The wheels must be `Solid` nodes, and
they must be named "right wheel" and "left wheel". If the wheel objects are
found, Webots will automatically make them rotate at the speed specified by the
`wb_differential_wheels_set_speed()` function.

The origin of the robot coordinate system is the projection on the ground plane
of the middle of the wheels' axle. The *x* axis is the axis of the wheel axle,
*y* is the vertical axis and *z* is the axis pointing towards the rear of the
robot (the front of the robot has negative *z* coordinates).

### Field Summary

### Simulation Modes

The `DifferentialWheels`'s motion can be computed by different algorithms:
"physics" or "kinematics" depending on the structure of the world.

#### Physics mode

A `DifferentialWheels` is simulated in "physics" mode if it contains `Physics`
nodes in its body and wheels. In this mode, the simulation is carried out by the
ODE physics engine, and the robot's motion is caused by the friction forces
generated by the contact of the wheels with the floor. The wheels can have any
arbitrary shape (usually a cylinder), but their contact with the floor is
necessary for the robot's motion. In "physics" mode the inertia, weight, etc. of
the robot and wheels is simulated, so for example the robot will fall if you
drop it. The friction is simulated with the Coulomb friction model, so a
`DifferentialWheels` robot would slip on a wall with some friction coefficient
that you can tune in the `Physics` nodes. The "physics" mode is the most
realistic but also the slowest simulation mode.

#### Kinematics mode

When a `DifferentialWheels` does not have `Physics` nodes then it is simulated
in "kinematics" mode. In the "kinematics" mode the robot's motion is calculated
according to 2D kinematics algorithms and the collision detection is calculated
with 3D algorithms. Friction is not simulated, so a `DifferentialWheels` does
not actually require the contact of the wheels with the floor to move. Instead,
its motion is controlled by a 2D kinematics algorithm using the  `axleLength,
wheelRadius` and `maxAcceleration` fields. Because friction is not simulated the
`DifferentialWheels` will not slide on a wall or on another robot. The
simulation will rather look as if obstacles (walls, robots, etc.) are very rough
or harsh. However the robots can normally avoid to become blocked by changing
direction, rotating the wheels backwards, etc. Unlike the "physics" mode, in the
"kinematics" mode the gravity and other forces are not simulated therefore a
`DifferentialWheels` robot will keep its initial elevation throughout the
simulation.

|  | Physics mode | Kinematics mode |
| --- | --- | --- | --- |
| Motion triggered by | Wheels friction | 2d Webots kinematics |
| Friction simulation | Yes, Coulomb model | No, robot slides against obstacles |
| Inertia/Weight/Forces | Yes | No |
| Collision detection | 3D (ODE) | 3D (ODE) |
| wheelRadius field | Ignored | Used |
| axleLength field | Ignored | Used |
| maxAcceleration field | Ignored | Used |
| maxForce field | Used | Ignored |
| Sensor rays shape | 3d cone | 3d cone |
| RGB sensitive | Yes | Yes |

### DifferentialWheels Functions

